# 深入探究原码、反码、补码

最近在学汇编语言时遭受了溢出、进位、cmp指令对有符号数和无符号数作用区别的毒打，因此在网上详细查询一下计算机内这两种整数表示的区别，最终来到了补码的原理问题上

## 机器数和真值

在了解上面那各种码之前，需要先了解一下机器码和真值的概念

#### 1、机器数

一个数在计算机中的二进制数表示形式，叫做这个数的机器数，机器数带有符号，其最高为1表示正负，正数为0，负数为1

例：十进制12的机器数：00001100，-12的机器数：10001100

#### 2、真值

由于机器数第一位是符号位，所以机器数的形式指不等于其实际值，例：机器数10000011，其形式指为131，但其实际值为-3。所以，为了区别起见，带有符号位的机器数对应的真正数值称为机器数的真值。

## 深入反码、补码

在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理为加法，这背后蕴含了什么数学原理呢？

将钟表想象成是一个1位的12进制数. 如果当前时间是8点, 我希望将时间设置成6点, 需要怎么做呢?我们可以:

> 1. 往回拨2个小时: 8 - 2 = 6
>
> 2. 往前拨10个小时: (8 + 10) mod 12 = 6
>
> 3. 往前拨10+12=22个小时: (8 + 22) mod 12 = 6

所以钟表往回拨(减法)的结果可以用往前拨(加法)替代！这就是加减法统一的直观感觉。

现在的焦点就落在了如何用一个正数, 来替代一个负数. 上面的例子我们能感觉出来一些规律. 但是数学是严谨的. 不能靠感觉.

首先介绍一个数学中相关的概念: [同余定理](https://baike.baidu.com/item/同余定理/1212360)

### 同余

两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余

记作 a ≡ b (mod m)

读作 a 与 b 关于模 m 同余。

举例说明:

> 4 mod 12 = 4
>
> 16 mod 12 = 4
>
> 28 mod 12 = 4

所以4, 16, 28关于模 12 同余.

### 负数取模

正数进行mod运算是很简单的. 但是负数呢？下面是使用"L"和"J"替换上图的"取下界"符号：

> x mod y = x - y L x / y J

上面公式的意思是：x mod y等于 x 减去 y 乘上 x与y的商的下界。以 -3 mod 2 举例：

>  -3 mod 2
>
> = -3 - 2xL -3/2 J
>
> = -3 - 2xL-1.5J
>
> = -3 - 2x(-2)
>
> = -3 + 4 = 1

所以:

> (-2) mod 12 = 12-2=10
>
> (-4) mod 12 = 12-4 = 8
>
> (-5) mod 12 = 12 - 5 = 7

再回到时钟的问题上:

> 回拨2小时 = 前拨10小时
>
> 回拨4小时 = 前拨8小时
>
> 回拨5小时= 前拨7小时

注意, 这里发现的规律!

结合上面学到的同余的概念.实际上:

> (-2) mod 12 = 10
>
> 10 mod 12 = 10

> (-4) mod 12 = 8
>
> 8 mod 12 = 8

-2与10、-4与8是同余的.

因此，要实现用正数替代负数, 只需要运用同余数的两个定理:

反身性:

> a ≡ a (mod m)

线性运算定理:

> 如果a ≡ b (mod m)，c ≡ d (mod m) 那么:
>
> (1)a ± c ≡ b ± d (mod m)
>
> (2)a * c ≡ b * d (mod m)

如果想看这个定理的证明, 请看:http://baike.baidu.com/view/79282.htm

所以:

> 7 ≡ 7 (mod 12)
>
> (-2) ≡ 10 (mod 12)
>
> 7 -2 ≡ 7 + 10 (mod 12)

现在我们为一个负数, 找到了它的正数同余数. 但是并不是7-2 = 7+10, 而是 7 -2 ≡ 7 + 10 (mod 12) , 即计算结果的余数相等.

接下来回到二进制的问题上, 看一下: 2-1=1的问题.

>  2-1=2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反

先到这一步, -1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126.

发现有如下规律：

> (-1) mod 127 = 126
>
> 126 mod 127 = 126

即:

> (-1) ≡ 126 (mod 127)
>
> 2-1 ≡ 2+126 (mod 127)

2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1

所以说一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!

而2+126很显然相当于钟表转过了一轮, 而因为符号位是参与计算的, 正好和溢出的最高位形成正确的运算结果.

既然反码可以将减法变成加法, 那么现在计算机使用的补码呢? 为什么在反码的基础上加1, 还能得到正确的结果?

> 2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补

如果把[1111 1111]当成原码, 去除符号位, 则:

> [0111 1111]原 = 127

其实, 在反码的基础上+1, 只是相当于增加了膜的值:

> (-1) mod 128 = 127
>
> 127 mod 128 = 127
>
> 2-1 ≡ 2+127 (mod 128)

此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128].

但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]



作者：[张子秋](http://www.cnblogs.com/zhangziqiu/)
出处：http://www.cnblogs.com/zhangziqiu/ 
本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。