作者：brucewall
链接：https://www.zhihu.com/question/58529163/answer/872599940
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



***话说在前头：**写这个回答是因为网上查找到的各种资料讲的都不是特别详细，当然明白的会觉得特别简单，但是刚面对这个结论的时候确实可能会比较懵逼。其实这个过程分析清楚还是挺简单的，但是要把里面的谬误和逻辑陷阱都理出来，写的就会比较绕了。**只对过程感到迷惑的同学只看我分割线夹着的部分就可以了。**语言组织多有不足，逻辑叙述部分因为归类需要多有重复，还请大家担待......*

首先，理解清这个规律的内涵，就是说：

1. **只要按照前序序列的顺序入栈，无论怎么出栈肯定是符合中序序列的**（如果出栈序列里面有几个不对应中序序列，那么你就没有办法言之凿凿说出栈序列是中序序列了，也就没有办法用卡特兰数解决相关问题了）。
2. **一个前序序列对应的所有二叉树，每一棵都必定对应一个出栈序列。**（每一棵二叉树都必然对应一个中序序列，故依着命题可推出每一个中序序列必须对应一个出栈序列，不存在多余的中序序列；而每一个出栈序列也对应一个中序序列，不存在多余的出栈序列）。

这里面要注意三点：

1. **这个前序序列、中序序列只是序列，不是树本身，不能确定树形。并不能保证任何一棵符合前序序列的树无论以何种顺序入栈出栈得到的一定是这颗树的中序序列。**道理很简单，前序序列和中序序列唯一确定一棵树，而同一个入栈顺序因出栈顺序的不同可以得到卡特兰数种序列，这棵树既然已经提前确定了，那么就只能对应其中一种序列。之所以要注意这一点是因为思考反例的时候会出现**思考方向上的错误**。举个例子：看到这个命题第一反应是举反例，最容易想到的反例就是根节点设为A，A有左子节点B和右子节点C，那么前序序列是ABC，出栈就是CBA，CBA并不是这个树的中序序列，从而就认为这个命题是错误的。但是其实命题没错，思考路径错了。错在提前定了这棵树，那肯定只有一种出栈顺序可以满足这棵树。CBA不是这个树的中序序列，但是肯定有一棵树可以用前序序列ABC和中序序列CBA来表示。
2. **一定会有一棵树同时既符合前序序列又符合如此推导出来的中序序列。**理由同（1），前序序列和中序序列唯一地确定一棵树。问题来了，怎么就知道推出来的这个是合法的中序序列？
3. **对每一棵符合前序序列的树，一定存在一个按照前序序列顺序入栈情况下的出栈顺序，使得以该出栈顺序得到的序列对应该树的中序序列。**这就麻烦了，还是和（2）一样的问题，一棵树肯定有一个中序序列，但你怎么就知道这个中序序列就一定可以由出栈顺序推导出来呢？

​    再来重申一下我们的**瓶颈**所在：**证明按照先序序列进栈，出栈的序列一定是一个中序序列。**

------

​    **下面来捋顺这个过程：**

​    先序序列是按照**根左右**的顺序进栈的。注意，假设你现在这个节点是p，先序序列是访问该节点p以后该结点p进栈，然后去访问p的左子树，访问p的左子树的时候依然还是这一套，**并不是访问完左子树的根节点就去访问右子树了，那是层序遍历。**

​    p的左子树也是先访问左子树根节点即p的左孩子，然后根节点（p的左子）入栈，再访问p左子树根节点（p的左子）的左子树......也就是说，看起来是根左右的顺序，**实际上压栈的时候，是先一路从根压到最左边的结点，不关所有的右结点的事。**右结点什么时候访问呢？不管是递归代码也好根据先序遍历的定义也好，是**左子树都处理完了，才开始访问右子树。**

​    我们来看一下压到最左边的结点时候发生什么事。我们把最左边的结点设为q，访问完q以后，q入栈，然后访问q的左孩子。注意虽然这个时候q的左孩子是空的，但是访问q的时候并不知道这一点，必须递归一次访问q的左孩子，进入先序遍历q的左孩子这一层递归时检测到是空的，才会知道到头了，该层递归跳出，然后开始退栈。**我们假设q的左孩子也就是空结点也有一个入栈再退栈的两步操作**，之所以这么假设是由于没有真实存在的操作夹在我们添加的虚的两步操作的中间，而我们添加两步过程前和后执行的效果没有发生任何改变，所以即使添加了过程也不影响我们对过程的分析，好比运算的时候比如配方的时候那个先加一项再减一项凑特殊公式的技巧；而且这个添加的过程可以帮助我们更好的把握整个流程的顺序。

​    我们来分析退栈顺序：第一个退栈的是这个空结点（q左子），然后是空结点的父节点q，然后按照我们前面分析的，这个时候算是q的左子树都处理完了，就开始访问空结点q的右子树。

​    这里还有一个细节问题，为什么不访问完左子树立刻访问右子树呢？我们首先从递归的角度分析，以最后一个节点为例，我们访问的是q，那么在调用q的左子进入递归的时候，递归程序里访问的是q->lchild，我们要保证递归返回后回到访问q的环境，就需要将q的信息压栈，q左子的递归返回以后，要通过弹栈的方式回到访问q的环境中。另外我们还可以这么想，如果不把q弹出来，我们是不知道q指向谁的，那么也就无法访问q的右子树，所以必须先弹出q，再来访问q的右子树。这里其实已经可以看到中序“左根右”的顺序了，后面只不过是递归而已。由于这里右子树只是访问还不是出栈，为了过程的完整性，下面把q结点的右子树入栈弹栈也分析一下。

​    右子树还是按照相同的过程，先把q的右孩子也就是q的右子树的根节点入栈，然后找右子树的最左结点......过程完全一致就不细表，我们可以把它们当成一个整体。**我们也暂不细研究右子树的出栈顺序，把它们看做右子树结点整体**。q退栈以后，右子树结点进栈，然后右子树结点退栈。这个过程是明白无误的。好，那么这样，q的父节点的左子树已经完成前序遍历进栈退栈。“左”访问完了，然后退栈得到q的父节点，然后访问q父节点的右子树也就是q的右兄弟......

​    综上，整个过程就是“左根右”，就是一个中序遍历的过程。这说明两方面内容：**一是对于这棵树，按先序遍历进栈再退栈得到的是中序序列，二是这棵树的中序序列可以由按先序遍历进栈的情况下的一种退栈顺序得到。**看起来像废话，实际上你对这两点的认识不够清晰就会产生谬误。

------

​    问题又来了，刚才的分析是一棵树完全进栈以后再退栈。那么这棵树从中间退栈呢？这个思考首先就犯了思考方向性上的错误。就是犯了前面提到的注意事项1提到的错误。我们是根据前序序列顺序入栈，把出栈序列当成中序序列一定可以找到这么一棵树，而不是提前规定好一棵树的树形，然后按先序遍历顺序入栈后以任意顺序退栈都可以得到这棵树的中序序列。这是不可能的，一棵树只有一种中序序列。

​    我们可以看出，以上分析是基于确定的树形的，这个确定不是指提前任意定好一个满足前序序列的树形，去推断出栈是否满足中序序列（相反，我们做的事情是任意定好一个满足前序序列的树形，去判断它的中序序列是否一定等于某个出栈序列）；这里的确定是相对的，是指我们总可以找到一个确定的、符合前序序列和分析出来的中序序列的树形，使其按前序序列进栈，出栈就是其中序序列。（简而言之就是**根据序列可限定找到树形，根据树形可找到对应序列**）综上两段，不存在“中间退栈”的情况，同一进栈顺序下不同的退栈顺序对应的就是不同的树（即不同的中序序列，因为树形定中序序列定），而不是同一棵树上不同的退栈情况；每一棵树的前序和中序情况都满足某一种退栈顺序。